<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Oribi Analytics -->
  <script type="application/javascript">
    (function(b,o,n,g,s,r,c){if(b[s])return;b[s]={};b[s].scriptToken="XzgzMjUyODI5Ng";b[s].callsQueue=[];b[s].api=function(){b[s].callsQueue.push(arguments);};r=o.createElement(n);c=o.getElementsByTagName(n)[0];r.async=1;r.src=g;r.id=s+n;c.parentNode.insertBefore(r,c);})(window,document,"script","https://cdn.oribi.io/XzgzMjUyODI5Ng/oribi.js","ORIBI");
  </script>
  <!-- End Oribi Analytics -->
  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-NLJ2P23');</script>
  <!-- End Google Tag Manager -->
  <meta charset="utf-8"/>
  <title>Luca Mingarelli</title>
  <link rel="icon" href="../../Icons/stork.png" type="image/png">
  <style>
    .collapsible {background-color: #777;color: white;cursor: pointer;  padding: 2px;width: 100%;
      border: none;  text-align: left;  outline: none;  font-size: 15px; border-radius: 2px;}
    /*.active,*/
    .collapsible:hover {  background-color: #555;}
    .content {display: none;  overflow: hidden;  background-color: #DCDCDC;}
  </style>
</head>

<!--<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>-->
<script>window.MathJax = {tex: {tags: 'ams'}};</script>
<script id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG"></script>-->

<link rel="stylesheet" href="../../PRISM/prism.css"> <!-- For code highlight -->
<script src="../../PRISM/prism.js"></script>         <!-- For code highlight -->


<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../../css/w3.css">
<link rel="stylesheet" href="../../css/font.css">
<link rel="stylesheet" href="../../css/responsiveiframe.css">
<script src="../../js/style_preamble.js"></script>

<body class="w3-light-grey w3-content" style="max-width:2600px">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NLJ2P23"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<!-- NavigationBar -->
<script src="../js/Navbar.js"></script>
<!-- _____________ -->
<!-- PRE_CONTENT -->
<script src="../js/pre_content.js"></script>
<!-- _____________ -->

<!-- ADD D3 -->
<script src="https://d3js.org/d3.v7.min.js"></script>




<div class="w3-content w3-justify" style="max-width:800px">

  <h1 style="text-align: left;"><b>Optimal Control Theory</b></h1>

<!--  <h2 style="text-align: left;"><b>The <i>efficiency-generality</i> trade-off</b></h2>-->

<h2 style="text-align: left;"><b>Defining the Problem</b></h2>
  

  <b>Definition 1 — Control function</b><blockquote><i> 
    A <strong>control function</strong>
    \(\mathbf{\gamma}(t)\) is a map from time \(t\in [0, \infty)\) to the set of <i>admissable controls</i> \(\Gamma\).
    <br>
    The control is also called a <strong>policy</strong>.
    
    </blockquote></i>
    <br>

    <b>Definition 2 — Controlled Dynamical System</b><blockquote><i> A system whose dynamics is described by the equation of motion
      
      \begin{equation}
      \dot{\mathbf{x}}(t)=\mathbf{f}(\mathbf{x}(t), \mathbf{\gamma}(t), t),
      \end{equation}
      
      is called a <strong>\(\mathbf{\gamma}\)-Controlled Dynamical System</strong>. 
      <br>
      A system which does not explicitely depent on time 
  
      \begin{equation}
      \dot{\mathbf{x}}(t)=\mathbf{f}(\mathbf{x}(t), \mathbf{\gamma}(t)),
      \end{equation}

      is called <strong>Autonomous</strong>.
      <br>
      The <strong>state</strong> of the system \(\mathbf{x}(t)\) is also called <strong>trajectory</strong>.
  

      </blockquote></i>
      <br>

      <b>Definition 3 — Payoff Functional</b><blockquote><i> A functional of the form
      
        \begin{equation}
        \mathbf{P}[\mathbf{\gamma}] := \int_0^T L(\mathbf{x}(t), \mathbf{\gamma}(t)) dt + \phi(\mathbf{x}(T)),
        \end{equation}
       
        is called a <strong>Payoff Functional</strong>, 
        where the function \(L\) is called <strong>running payoff</strong> or <strong>Lagrangian</strong> 
        and \(\phi\) is called <strong>terminal payoff</strong> or <strong>boundary cost</strong> (sometimes also referred to as Mayer's Term).
        </blockquote></i>
        <br>
  
  

  <b>Definition 4 — Optimal Control Problem</b><blockquote><i> 
    Given a system with controls \(\mathbf{\gamma}\) 
    and payoff functional \(\mathbf{P}[\mathbf{\gamma}]\), 
    the associated <strong>Optimal Control Problem </strong> amounts to finding 
    an <strong>optimal control</strong> \(\mathbf{\gamma}^*\) maximising the payoff: 
    
    \begin{equation}
    \mathbf{P}[\mathbf{\gamma}^*] = \max_{\mathbf{\gamma}\in\Gamma} \mathbf{P}[\mathbf{\gamma}],
    \end{equation}

    that is
    \begin{equation}
    \mathbf{P}[\mathbf{\gamma}^*] \ge \mathbf{P}[\mathbf{\gamma}], \quad \forall \mathbf{\gamma}\in\Gamma.
    \end{equation}

    <br>
    The problem is called a Lagrange problem when \(\phi=0\), and a Mayer problem when \(L=0\).
    When both \(L\ne0\) and \(\phi\ne0\) it is also called a Bolza Problem <a href="#ref1">[1]</a>.

    </blockquote></i>
    <br>

    Real world applications are abundant. Examples include: xxx
    
    
    <h2 style="text-align: left;"><b>Dynamic Programming</b></h2>


    <br><br>


    <b>Definition 5 — Bellman's Principle of Optimality</b><blockquote><i> 

      For any point \(\tau>0\) on an optimal trajectory \(\mathbf{x}(t)\), 
      the remaining trajectory \(\mathbf{x}(t>\tau)\) is optimal 
      for the corresponding problem initiated at \(\tau\).

      <br><br>
      Or, in Bellman's own words <a href="#ref2">[2]</a>: 
      <br><br>
      "An optimal policy has the property that whatever 
      the initial state and initial decision are, 
      the remaining decisions must constitute an optimal policy 
      with regard to the state resulting from the first decision."
    
    
    
    </blockquote></i>
    <br>




    <h2 style="text-align: left;"><b>Solving the Problem</b></h2>


    <b>Definition x — Hamiltonian</b><blockquote><i> 
      Given a system with controls \(\mathbf{\gamma}\), 
      payoff functional \(\mathbf{P}[\mathbf{\gamma}]\),
      and dynamics of the state variable \(\mathbf{x}\) 
      governed by the law of motion 
      \(\dot{\mathbf{x}}(t)=\mathbf{f}(\mathbf{x}(t), \mathbf{\gamma}(t), t)\)
      
      the <strong>control Hamiltonian</strong> is
      
      \begin{equation}
      H(\mathbf{x}(t), \mathbf{\gamma}(t), \lambda(t), t) := L(\mathbf{x}(t), \mathbf{\gamma}(t), t) +\lambda^T(t)  \mathbf{f}(\mathbf{x}(t), \mathbf{\gamma}(t), t),
      \end{equation}     
      where \(L\) is the Lagrangian term in \(\mathbf{P}\) (running payoff),
      and \(\lambda\) is called the <strong>co-state</strong> variable.
      
    
    </blockquote></i>
    <br>
  Notice that the multiplier (or co-state) \(\lambda(t)\), 
  unlike the Lagrangian multiplier in static optimisation, depends on time </strong><a href="#ref3">[3]</a>.
  <br>



  <br><br>

  <b>Theorem xx — Pontryagin Maximum Principle</b><blockquote><i> 
    Assume the optimal control \(\mathbf{\gamma}^*\) is known and admissable (\(\mathbf{\gamma}^*\in\Gamma\)), 
    which generates the associated optimal trajectory \(\mathbf{x}^*\). 
    Then, there exists and adjoint trajectory \(\mathbf{p}^*\) conjugate to \(\mathbf{x}^*\) 
    such that

    \begin{equation}
    \begin{split}
    \dot{\mathbf{x}}(t) &= \nabla_\lambda H(\mathbf{x}^*, \mathbf{\gamma}^*, \lambda^*, t) \quad\quad\quad\quad \phantom{-} (\text{state equation})\\
    \dot{\lambda}(t) &= -\nabla_\mathbf{x} H(\mathbf{x}^*, \mathbf{\gamma}^*, \lambda^*, t) \quad\quad\quad\quad (\text{co-state equation})\\
     H(\mathbf{x}^*, \mathbf{\gamma}^*, \lambda^*, t) &\ge H(\mathbf{x}^*, \mathbf{\gamma}^*, \lambda, t), \quad \forall \gamma \in \Gamma \quad \phantom{-.} (\text{Pontryagin Maximum Principle})
    \end{split}
    \end{equation}     


  </blockquote></i>
  <br>

  In other words, Pontryagin's Maximum Principle provides a necessary condition for optimality.

  <br>


<!-- STEP 3: THE JAVASCRIPT GRAPH -->
<!-- <script src="https://erdogant.github.io/datasets/d3js/d3.v3.js"></script>
<script src="./chart.js"></script> -->




  
  <!-- STEP 2: THE D3 MODULE -->
    <script src="https://erdogant.github.io/datasets/d3js/d3.v3.js"></script>
  <!-- END STEP 2 -->
  
    <script>
  
  <!-- STEP 3: THE JAVASCRIPT GRAPH -->
  
        function d3graphscript(config = {
          // Default values
          width: 800,
          height: 600,
          charge: -250,
          distance: 0,
          directed: false,
          collision: 0.5
        }) {
          console.log('d3graphscript config = ', config);
  
          //Constants for the SVG
          var width = config.width;
          var height = config.height;
  
          //Set up the colour scale
          var color = d3.scale.category20();
  
          var force = d3.layout.force()
            .charge(config.charge)
            .linkDistance((d) => config.distance > 0 ? config.distance : d.edge_weight)
            .size([width, height]);
  
  
          //Append a SVG to the body of the html page. Assign this SVG as an object to svg
          var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
          //.on("dblclick", threshold); // EXPLODE ALL CONNECTED POINTS
  
          graphRec = JSON.parse(JSON.stringify(graph));
  
          //Creates the graph data structure out of the json data
          force.nodes(graph.nodes)
            .links(graph.links)
            .start();
  
          //Create all the line svgs but without locations yet
          var link = svg.selectAll(".link")
            .data(graph.links)
            .enter().append("line")
            .attr("class", "link")
            .style("marker-end", () => config.directed ? "url(#suit)" : "none") // ARROWS IN EDGES
            .style("stroke-width", function(d) {return d.edge_width;}) // LINK-WIDTH
            ;
          //  .style("stroke-width", 1); // WIDTH OF THE LINKS
  
          //Do the same with the circles for the nodes
          var node = svg.selectAll(".node")
            .data(graph.nodes)
            .enter().append("g")
            .attr("class", "node")
            .call(force.drag)
            .on('dblclick', connectedNodes); //Highliht ON/OFF
  
          node.append("circle")
            .attr("r", function(d) { return d.node_size; })					// NODE SIZE
            .style("fill", function(d) {return d.node_color;})				// NODE-COLOR
            .style("stroke-width", function(d) {return d.node_size_edge;})	// NODE-EDGE-SIZE
            .style("stroke", function(d) {return d.node_color_edge;})		// NODE-COLOR-EDGE
          //  .style("stroke", '#000')										// NODE-EDGE-COLOR (all black)
  
          // Text in nodes
          node.append("text")
            .attr("dx", 10)
            .attr("dy", ".35em")
            .text(function(d) {return d.node_name}) // NODE-TEXT
          //  .style("stroke", "gray");
  
          let showInHover = ["node_name"];
          node.append("title")
              .text((d) => Object.keys(d)
                  .filter((key) => showInHover.indexOf(key) !== -1)
                  .map((key) => `${key}: ${d[key]}`)
                  .join('\n')
              )
  
          //Now we are giving the SVGs co-ordinates - the force layout is generating the co-ordinates which this code is using to update the attributes of the SVG elements
          force.on("tick", function() {
            link.attr("x1", function(d) {
                return d.source.x;
              })
              .attr("y1", function(d) {
                return d.source.y;
              })
              .attr("x2", function(d) {
                return d.target.x;
              })
              .attr("y2", function(d) {
                return d.target.y;
              });
            d3.selectAll("circle").attr("cx", function(d) {
                return d.x;
              })
              .attr("cy", function(d) {
                return d.y;
              });
            d3.selectAll("text").attr("x", function(d) {
                return d.x;
              })
              .attr("y", function(d) {
                return d.y;
              });
  
            node.each(collide(config.collision)); //COLLISION DETECTION. High means a big fight to get untouchable nodes (default=0.5)
  
          });
  
          // --------- Directed lines -----------
          svg.append("defs").selectAll("marker")
              .data(["suit", "licensing", "resolved"])
            .enter().append("marker")
              .attr("id", function(d) { return d; })
              .attr("viewBox", "0 -5 10 10")
              .attr("refX", 25)
              .attr("refY", 0)
              .attr("markerWidth", 10)
              .attr("markerHeight", 10)
              .attr("orient", "auto")
              .attr("markerUnits", "userSpaceOnUse") // MAKE FIXED ARROW WIDTH
            .append("path")
              .attr("d", "M0,-5L10,0L0,5 L10,0 L0, -5")
              .style("stroke", "grey") // ARROWHEAD GREY
              .style("opacity", "0.6")
              .style("stroke-width", '1.5'); // THICKNESS OF ARROWHEAD
  
          // --------- End directed lines -----------
  
          //---Insert-------
  
  
          // collision detection
  
          var padding = 1, // separation between circles
            radius = 8;
  
          function collide(alpha) {
            var quadtree = d3.geom.quadtree(graph.nodes);
            return function(d) {
              var rb = 2 * radius + padding,
                nx1 = d.x - rb,
                nx2 = d.x + rb,
                ny1 = d.y - rb,
                ny2 = d.y + rb;
              quadtree.visit(function(quad, x1, y1, x2, y2) {
                if (quad.point && (quad.point !== d)) {
                  var x = d.x - quad.point.x,
                    y = d.y - quad.point.y,
                    l = Math.sqrt(x * x + y * y);
                  if (l < rb) {
                    l = (l - rb) / l * alpha;
                    d.x -= x *= l;
                    d.y -= y *= l;
                    quad.point.x += x;
                    quad.point.y += y;
                  }
                }
                return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
              });
            };
          }
          // collision detection end
  
  
          //Toggle stores whether the highlighting is on **********************
          var toggle = 0;
          //Create an array logging what is connected to what
          var linkedByIndex = {};
          for (i = 0; i < graph.nodes.length; i++) {
            linkedByIndex[i + "," + i] = 1;
          };
          graph.links.forEach(function(d) {
            linkedByIndex[d.source.index + "," + d.target.index] = 1;
          });
          //This function looks up whether a pair are neighbours
          function neighboring(a, b) {
            return linkedByIndex[a.index + "," + b.index];
          }
  
          function connectedNodes() {
            if (toggle == 0) {
              //Reduce the opacity of all but the neighbouring nodes
              d = d3.select(this).node().__data__;
              node.style("opacity", function(o) {
                return neighboring(d, o) | neighboring(o, d) ? 1 : 0.1;
              });
              link.style("opacity", function(o) {
                return d.index == o.source.index | d.index == o.target.index ? 1 : 0.1;
              });
              //Reduce the op
              toggle = 1;
            } else {
              //Put them back to opacity=1
              node.style("opacity", 1);
              link.style("opacity", 1);
  
              toggle = 0;
            }
          }
          //*************************************************************
  
  
          //adjust threshold
          function threshold() {
            let thresh = this.value;
  
            console.log('Setting threshold', thresh)
            graph.links.splice(0, graph.links.length);
  
            for (var i = 0; i < graphRec.links.length; i++) {
              if (graphRec.links[i].edge_weight > thresh) {
                graph.links.push(graphRec.links[i]);
              }
            }
            restart();
          }
  
          d3.select("#thresholdSlider").on("change", threshold);
  
          //Restart the visualisation after any node and link changes
          function restart() {
  
            link = link.data(graph.links);
            link.exit().remove();
            link.enter().insert("line", ".node").attr("class", "link");
            link.style("stroke-width", function(d) {return d.edge_width;}); // WIDTH OF THE LINKS AFTER BREAKING WITH SLIDER
            link.style("marker-end", () => config.directed ? "url(#suit)" : "none") // ARROWS IN EDGES
            node = node.data(graph.nodes);
            node.enter().insert("circle", ".cursor").attr("class", "node").attr("r", 5).call(force.drag);
            force.start();
          }
        }
  
  <!-- END STEP 3 -->
  
  <!-- STEP 4: DATA -->
    graph = {"links":[{"weight":5.56,"edge_weight":5.56,"edge_width":20.0,"source_label":"node_A","target_label":"node_F","source":0,"target":2},{"weight":3.28,"edge_weight":3.28,"edge_width":12.20863309352518,"source_label":"node_A","target_label":"node_M","source":0,"target":4},{"weight":0.45,"edge_weight":0.45,"edge_width":2.537769784172662,"source_label":"node_Z","target_label":"node_A","source":6,"target":0},{"weight":0.5,"edge_weight":0.5,"edge_width":2.70863309352518,"source_label":"node_F","target_label":"node_B","source":2,"target":1},{"weight":0.5,"edge_weight":0.5,"edge_width":2.70863309352518,"source_label":"node_C","target_label":"node_M","source":5,"target":4},{"weight":0.64,"edge_weight":0.64,"edge_width":3.1870503597122304,"source_label":"node_B","target_label":"node_J","source":1,"target":3}],"nodes":[{"node_name":"node_A","node_color":"#000080","node_size":"10","node_size_edge":"0.10000000000000009","node_color_edge":"#000000"},{"node_name":"node_B","node_color":"#000080","node_size":"10","node_size_edge":"0.10000000000000009","node_color_edge":"#000000"},{"node_name":"node_F","node_color":"#000080","node_size":"10","node_size_edge":"0.10000000000000009","node_color_edge":"#000000"},{"node_name":"node_J","node_color":"#000080","node_size":"10","node_size_edge":"0.10000000000000009","node_color_edge":"#000000"},{"node_name":"node_M","node_color":"#000080","node_size":"10","node_size_edge":"0.10000000000000009","node_color_edge":"#000000"},{"node_name":"node_C","node_color":"#000080","node_size":"10","node_size_edge":"0.10000000000000009","node_color_edge":"#000000"},{"node_name":"node_Z","node_color":"#000080","node_size":"10","node_size_edge":"0.10000000000000009","node_color_edge":"#000000"}]}
  <!-- END STEP 4 -->
  
      window.addEventListener('DOMContentLoaded', function () {
  
        d3graphscript({
                  width: 1500,
                  height: 800,
                  charge: -250,
                  distance: 30,
                  directed: false,
                  collision: 0.5
              })
          });
    
    </script>





  <h4 id="REFERENCES"><i>References and notes</i></h4>

  [1] <a href="https://link.springer.com/article/10.1007/BF02419594" id="ref1">"Über zwei Euler’sche Aufgaben aus der Variationsrechnung", Oskar Bolza, 1913, Annali di Matematica Pura ed Applicata</a>
  <br>
  [2] <a href="https://gwern.net/doc/statistics/decision/1957-bellman-dynamicprogramming.pdf" id="ref2">"Dynamic Programming", Richard Bellman, 1957, Chap. III.3. </a>
  <br>
  [3] <normal id="ref3">Notice that while related, the Control Hamiltonian of optimal control theory is distinct from the Hamiltonian used in mechanics. 
    In particular, the latter is used to derive the equation of motion of a dynamical system. 
    The Hamiltonian of optimal control theory instead, is a concept developed by Lev Pontryagin, 
    with the purpose to provide conditions for extrimising a functional with respect to a control variable. <normal>
  <br>

<!--  https://bookdown.org/egarpor/NP-UC3M/kde-ii-asymp.html-->
<!--  https://bookdown.org/egarpor/NP-EAFIT/intro-nonpar.html-->

<!--  https://bookdown.org/egarpor/inference/-->
<!--  https://bookdown.org/egarpor/PM-UC3M/-->


  <br><br>

  <!-- ________________________________________________________________________________________________ -->
  <!-- ________________________________________________________________________________________________ -->
  <!-- ________________________________________________________________________________________________ -->
  <!--    <h7>-->
  <!-- <span style="float:right;">
 <a href="./L2.html"><b><img src="../Icons/next.png" width="20px" align="right">Next</b></a>
 </span>
 </h7>
 <br> -->

  <h5> <a href="../../Teaching.html"><b><img src="../../Icons/back.png" width="20px"> Back to Teaching</b></a></h5>



  <hr class="w3-opacity">
</div>
</div>
<script type="text/javascript" src="../../js/footer.js"></script>

<!-- End page content -->
</div>

<script src="../../js/OpenCloseSidebar.js"></script>
<!--<script src="../js/ModalImageGallery.js"></script>-->
<script src="../../js/OpenCloseCollapsible.js"></script>

</body>
</html>
